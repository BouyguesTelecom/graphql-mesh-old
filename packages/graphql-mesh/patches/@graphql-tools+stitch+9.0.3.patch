diff --git a/node_modules/@graphql-tools/stitch/cjs/typeCandidates.js b/node_modules/@graphql-tools/stitch/cjs/typeCandidates.js
index c915942..b8e799d 100644
--- a/node_modules/@graphql-tools/stitch/cjs/typeCandidates.js
+++ b/node_modules/@graphql-tools/stitch/cjs/typeCandidates.js
@@ -119,6 +119,24 @@ function buildTypes({ typeCandidates, directives, stitchingInfo, rootTypeNames,
             (typeof mergeTypes === 'function' && mergeTypes(typeCandidates[typeName], typeName)) ||
             (Array.isArray(mergeTypes) && mergeTypes.includes(typeName)) ||
             (stitchingInfo != null && typeName in stitchingInfo.mergedTypes)) {
+
+              // Custom Object-Interface stitching
+              const candidates = typeCandidates[typeName].sort((a, b) => a.subschema.name.localeCompare(b.subschema.name));
+              let initialCandidateType = candidates[0].type;
+              if (candidates.some(candidate => candidate.type.constructor !== initialCandidateType.constructor)) {
+                const candidatesI = candidates.filter((c) => c.type.constructor.name === "GraphQLInterfaceType");
+                const candidatesObj  = candidates.filter((c) => c.type.constructor.name === "GraphQLObjectType");
+                
+                if (candidatesI.length + candidatesObj.length === candidates.length) {
+                  let finalI = candidatesI[0];
+                  const otherCandidates = candidatesI.slice(1,candidatesI.length).concat(candidatesObj);
+                  otherCandidates.forEach((otherCandidate) => {
+                    finalI.type._fields = {...finalI.type._fields, ...otherCandidate.type._fields};
+                  });
+                  typeCandidates[typeName] = [finalI];
+                }
+              }
+
             typeMap[typeName] = (0, mergeCandidates_js_1.mergeCandidates)(typeName, typeCandidates[typeName], typeMergingOptions);
         }
         else {
@@ -128,6 +146,26 @@ function buildTypes({ typeCandidates, directives, stitchingInfo, rootTypeNames,
             typeMap[typeName] = candidateSelector(typeCandidates[typeName]).type;
         }
     }
+
+    /**
+     * When the "allOf" key is used, an object needs to have every propreties 
+     * of its parent. Because interfaces have been possibly merged earlier in
+     * the patch, this statement is sometimes not true anymore.
+     */
+    Object.values(typeMap).forEach((type) => {
+      if (type.constructor.name === "GraphQLObjectType") {
+        if (type.astNode.interfaces.length !== 0) {
+          type._interfaces = [];
+          type.astNode.interfaces.forEach((i) => {
+            const iName = i.name.value;
+            const iFields = typeMap[iName].getFields();
+            type._interfaces.push(typeMap[iName]);
+            type.setFields(iFields);
+          });
+        }
+      }
+    });
+
     return (0, utils_1.rewireTypes)(typeMap, directives);
 }
 exports.buildTypes = buildTypes;
